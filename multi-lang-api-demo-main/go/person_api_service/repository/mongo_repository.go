package repository

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/example/person_api_service/database"
	"github.com/example/person_api_service/models"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// MongoPersonRepository implements PersonRepositoryInterface for MongoDB.
type MongoPersonRepository struct {
	Collection *mongo.Collection
}

// NewMongoPersonRepository creates a new instance of MongoPersonRepository.
func NewMongoPersonRepository() *MongoPersonRepository {
	if database.MongoClient == nil {
		database.InitMongoDB() // Ensure client is initialized
	}
	// Ensure indexes are created
	coll := database.GetPersonCollection()
	ensureIndexes(coll)
	return &MongoPersonRepository{Collection: coll}
}

// ensureIndexes creates necessary indexes for the persons collection.
func ensureIndexes(collection *mongo.Collection) {
	// Index for email (unique)
	emailIndex := mongo.IndexModel{
		Keys:    bson.D{{Key: "email", Value: 1}},
		Options: options.Index().SetUnique(true),
	}

	// Index for search by name (first_name, last_name)
	nameIndex := mongo.IndexModel{
		Keys: bson.D{
			{Key: "first_name", Value: 1},
			{Key: "last_name", Value: 1},
		},
	}

	// Index for list by city and state
	cityStateIndex := mongo.IndexModel{
		Keys: bson.D{
			{Key: "city", Value: 1},
			{Key: "state", Value: 1},
		},
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	_, err := collection.Indexes().CreateMany(ctx, []mongo.IndexModel{emailIndex, nameIndex, cityStateIndex})
	if err != nil {
		// Log the error but don't necessarily fail startup, as it might be a transient issue or permission problem.
		// The application can still function, albeit potentially slower for some queries or without uniqueness enforcement at DB level.
		log.Printf("Error creating indexes for MongoDB: %v. Check MongoDB logs for more details.", err)

		// More detailed error logging based on type of error if possible
		if bulkErr, ok := err.(mongo.BulkWriteException); ok {
			for _, writeErr := range bulkErr.WriteErrors {
				log.Printf("MongoDB Index Write Error: Code=%d, Message=%s", writeErr.Code, writeErr.Message)
			}
		} else if cmdErr, ok := err.(mongo.CommandError); ok {
			log.Printf("MongoDB Index Command Error: Code=%d, Message=%s, Name=%s", cmdErr.Code, cmdErr.Message, cmdErr.Name)
		}

		// If running in a context where this is critical (e.g., initial setup), consider a panic or fatal log.
		// For a running service, logging might be sufficient.
		// For example, if os.Getenv("FAIL_ON_INDEX_ERROR") == "true" { log.Fatalf(...) }
	} else {
		log.Println("MongoDB indexes ensured successfully.")
	}
}

// CreatePerson adds a new person to the MongoDB collection.
func (r *MongoPersonRepository) CreatePerson(personData models.PersonCreate) (*models.Person, error) {
	person := models.Person{
		// ID will be generated by MongoDB
		FirstName: personData.FirstName,
		LastName:  personData.LastName,
		Email:     personData.Email,
		Phone:     personData.Phone,
		Address:   personData.Address,
		City:      personData.City,
		State:     personData.State,
		ZipCode:   personData.ZipCode,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	res, err := r.Collection.InsertOne(ctx, person)
	if err != nil {
		log.Printf("Error inserting person into MongoDB: %v", err)
		if mongo.IsDuplicateKeyError(err) {
			return nil, errors.New("email already exists")
		}
		return nil, err
	}

	insertedID, ok := res.InsertedID.(primitive.ObjectID)
	if !ok {
		log.Printf("Failed to convert InsertedID to ObjectID")
		return nil, errors.New("error getting inserted ID")
	}
	person.ID = insertedID
	return &person, nil
}

// GetPerson retrieves a person by their ID from MongoDB.
func (r *MongoPersonRepository) GetPerson(idStr string) (*models.Person, error) {
	objID, err := primitive.ObjectIDFromHex(idStr)
	if err != nil {
		log.Printf("Invalid ID format for MongoDB: %s", idStr)
		return nil, errors.New("invalid ID format")
	}

	var person models.Person
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = r.Collection.FindOne(ctx, bson.M{"_id": objID}).Decode(&person)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil // Person not found
		}
		log.Printf("Error finding person in MongoDB: %v", err)
		return nil, err
	}
	return &person, nil
}

// UpdatePerson modifies an existing person's details in MongoDB.
func (r *MongoPersonRepository) UpdatePerson(idStr string, personData models.PersonUpdate) (*models.Person, error) {
	objID, err := primitive.ObjectIDFromHex(idStr)
	if err != nil {
		log.Printf("Invalid ID format for MongoDB update: %s", idStr)
		return nil, errors.New("invalid ID format")
	}

	updateFields := bson.M{}
	if personData.FirstName != "" {
		updateFields["first_name"] = personData.FirstName
	}
	if personData.LastName != "" {
		updateFields["last_name"] = personData.LastName
	}
	if personData.Email != "" {
		updateFields["email"] = personData.Email
	}
	if personData.Phone != "" {
		updateFields["phone"] = personData.Phone
	}
	if personData.Address != "" {
		updateFields["address"] = personData.Address
	}
	if personData.City != "" {
		updateFields["city"] = personData.City
	}
	if personData.State != "" {
		updateFields["state"] = personData.State
	}
	if personData.ZipCode != "" {
		updateFields["zip_code"] = personData.ZipCode
	}

	if len(updateFields) == 0 {
		// No fields to update, fetch and return current document
		return r.GetPerson(idStr)
	}

	update := bson.M{"$set": updateFields}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	result, err := r.Collection.UpdateOne(ctx, bson.M{"_id": objID}, update)
	if err != nil {
		log.Printf("Error updating person in MongoDB: %v", err)
		if mongo.IsDuplicateKeyError(err) {
			return nil, errors.New("email already exists")
		}
		return nil, err
	}

	if result.MatchedCount == 0 {
		return nil, nil // Person not found
	}
    if result.ModifiedCount == 0 && result.MatchedCount == 1 {
        // Document was matched but not modified (e.g. update data is same as existing)
        // Fall through to fetch and return the document
    }


	// Fetch the updated document
	var updatedPerson models.Person
	err = r.Collection.FindOne(ctx, bson.M{"_id": objID}).Decode(&updatedPerson)
	if err != nil {
		log.Printf("Error fetching updated person from MongoDB: %v", err)
		return nil, err // Should ideally not happen if update was successful
	}
	return &updatedPerson, nil
}

// DeletePerson removes a person from the MongoDB collection by ID.
func (r *MongoPersonRepository) DeletePerson(idStr string) (bool, error) {
	objID, err := primitive.ObjectIDFromHex(idStr)
	if err != nil {
		log.Printf("Invalid ID format for MongoDB delete: %s", idStr)
		return false, errors.New("invalid ID format")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	result, err := r.Collection.DeleteOne(ctx, bson.M{"_id": objID})
	if err != nil {
		log.Printf("Error deleting person from MongoDB: %v", err)
		return false, err
	}

	return result.DeletedCount > 0, nil
}

// SearchByName finds persons by first and/or last name in MongoDB.
func (r *MongoPersonRepository) SearchByName(firstName, lastName string) ([]models.Person, error) {
	filter := bson.M{}
	if firstName != "" {
		filter["first_name"] = bson.M{"$regex": primitive.Regex{Pattern: "^" + firstName, Options: "i"}} // Case-insensitive prefix search
	}
	if lastName != "" {
		filter["last_name"] = bson.M{"$regex": primitive.Regex{Pattern: "^" + lastName, Options: "i"}}   // Case-insensitive prefix search
	}

    if len(filter) == 0 {
        // If no search terms, return all persons or an empty list based on requirements.
        // Returning all for now.
        // To return an error: return nil, errors.New("search criteria (firstName or lastName) must be provided")
    }

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	cursor, err := r.Collection.Find(ctx, filter)
	if err != nil {
		log.Printf("Error searching persons in MongoDB: %v", err)
		return nil, err
	}
	defer cursor.Close(ctx)

	var persons []models.Person
	if err = cursor.All(ctx, &persons); err != nil {
		log.Printf("Error decoding search results from MongoDB: %v", err)
		return nil, err
	}
	if persons == nil { // Ensure empty slice instead of nil if no results
		persons = []models.Person{}
	}

	return persons, nil
}

// ListByCityState retrieves persons by city and state from MongoDB.
func (r *MongoPersonRepository) ListByCityState(city, state string) ([]models.Person, error) {
	if city == "" || state == "" {
		return nil, errors.New("city and state must be provided")
	}

	filter := bson.M{
		"city":  bson.M{"$regex": primitive.Regex{Pattern: "^" + city + "$", Options: "i"}},  // Case-insensitive exact match
		"state": bson.M{"$regex": primitive.Regex{Pattern: "^" + state + "$", Options: "i"}}, // Case-insensitive exact match
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	cursor, err := r.Collection.Find(ctx, filter)
	if err != nil {
		log.Printf("Error listing persons by city/state in MongoDB: %v", err)
		return nil, err
	}
	defer cursor.Close(ctx)

	var persons []models.Person
	if err = cursor.All(ctx, &persons); err != nil {
		log.Printf("Error decoding city/state list results from MongoDB: %v", err)
		return nil, err
	}
    if persons == nil { // Ensure empty slice instead of nil if no results
		persons = []models.Person{}
	}
	return persons, nil
}
